#!/bin/bash
# -*- mode: sh; sh-basic-offset: 2; indent-tabs-mode: nil; -*-
# vim:set ft=sh et sw=2 ts=2:
#
# dhclient-ipv6-prefix v1.99.0 - dhclient script for ipv6 Prefix Delegation
# Author: Scott Shambarger <devel@shambarger.net>
#
# Copyright (C) 2014-2021 Scott Shambarger
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Instructions for use:
#
#   Place somewhere in your dispatcher's PATH, and then touch the
#   file NMCONF/ipv6-prefix-<wan>.conf, and optionally put the following
#   setting in it:
#
#     WAN_LAN_INTFS=<lan>
#
#   See 08-ipv6-prefix for full documentation
#
# SELinux note:
#
#   This file should be labeled so that the dispatcher and dhclient can
#   use it.  By default, /usr/sbin is a good location.
#
# Also requires:
#
#   NMUTILS/general-functions - shared functions
#   /etc/NetworkManager/dispatcher.d/08-ipv6-prefix - NM trigger script
#   dhclient - ISC DHCP client
#
# Supported, but optional:
#
#   NMUTILS/ddns-functions - dynamic DNS functions
#
# dhclient is expected to setup environment with $interface and $reason,
#    and conditionally $old_ip6_prefix, $new_ip6_prefix and $new_max_life
#
# NOTE: executable paths (see below) may be overriden if needed
#
# shellcheck disable=SC1090

# for logging
NMG_TAG="${NMG_TAG-ipv6-prefix-dhc}"

# set NMUTILS/NMCONF early, and allow environment to override
NMUTILS="${NMUTILS:-/etc/nmutils}"
NMCONF="${NMCONF:-${NMUTILS}/conf}"

########## Global defaults (customize in $NMCONF/general.conf)

########## Default paths

RUNDIR="${RUNDIR:-/run/nmutils}"
LEASEDIR="${LEASEDIR:-/var/lib/dhclient}"
ACCEPT_RA="${ACCEPT_RA:-/proc/sys/net/ipv6/conf/@WAN@/accept_ra}"
# sysctl forwarding state (must contain "@NODE@")
FORWARDING_PAT="${FORWARDING_PAT:-/proc/sys/net/ipv6/conf/@NODE@/forwarding}"

########## Support programs

DHCLIENT=${DHCLIENT:-dhclient}
# FIXME DIFFERS
DHSCRIPT=${DHSCRIPT:-$0}
# these may be empty
DHCLIENT_ORIG_SCRIPT=${DHCLIENT_ORIG_SCRIPT-dhclient-script}
NMCLI=${NMCLI-nmcli}
NMDATE=${NMDATE:-date}

########## Config overrides

# set to 1 to spawn dhclient even if NetworkManager method=auto
NMDH6_IGNORE_METHOD_AUTO=${NMDH6_IGNORE_METHOD_AUTO-}
# by default, request addresses and prefixes... (cleared if method=auto)
NMDH6_DHCLIENT_ARGS=("-N")

########## SCRIPT START

NMG_REQUIRED="1.5.6"
NMDDNS_REQUIRED="1.4.3"

# load ddns- or general-functions
NMDDNS=${NMDDNS-${NMUTILS}/ddns-functions}
{ [[ -r ${NMDDNS} ]] && . "${NMDDNS}"; } || {
  # no DDNS, use general-functions
  NMDDNS='' NMG=${NMG:-${NMUTILS}/general-functions}
  { [[ -r ${NMG} ]] && . "${NMG}"; } || {
    echo 1>&2 "Unable to load ${NMG}"; exit 2; }
}

[[ ${NMG_VERSION} ]] || {
  nmg_err "${0##*/} requires NMG ${NMG_REQUIRED}"; exit 2; }
[[ -z ${NMDDNS} || ${NMDDNS_VERSION} ]] || {
  nmg_err "${0##*/} requires NMDDNS ${NMDDNS_REQUIRED}"; exit 2; }

[[ ${interface-} ]] || {
  echo >&2 "${0##*/} requires 'interface' in the environment" && exit 4; }

########## Config/state locations

# override LEASEDIR, not LEASES
LEASES="${LEASEDIR}/ipv6-prefix-@WAN@.leases"
# override RUNDIR, not DHCLIENT_PID
DHCLIENT_PID="${RUNDIR}/dhclient-ipv6-prefix-@WAN@.pid"

# main config
WAN_CONFIG_PAT=${WAN_CONFIG_PAT:-${NMCONF}/ipv6-prefix-@WAN@.conf}

##### WAN address

# iaid state (must contain "@ID@-@WAN@")
WAN_STATE_PAT=${WAN_STATE_PAT:-${RUNDIR}/ipv6-@ID@-@WAN@.state}

# DDNS config
WAN_DDNS_CONFIG_PAT=${WAN_DDNS_CONFIG_PAT:-${NMCONF}/ddns-@WAN@.conf}
# DDNS state (must contain "@WAN@-@RREC@")
WAN_DDNS_STATE_PAT=${WAN_DDNS_STATE_PAT:-${RUNDIR}/ddns-@WAN@-@RREC@.state}

#### prefix LAN (LAN_*_PAT values must have a single @LAN@ keyword)

# main LAN config (must contain "@LAN@-from-@WAN@")
LAN_CONFIG_PAT=${LAN_CONFIG_PAT:-${NMCONF}/ipv6-prefix-@LAN@-from-@WAN@.conf}

# node assignment state (must contain "@LAN@-from-@ID@-@WAN@")
LAN_STATE_PAT=${LAN_STATE_PAT:-${RUNDIR}/ipv6-prefix-@LAN@-from-@ID@-@WAN@.state}

# DDNS config (must contain "@LAN@-from-@WAN@")
LAN_DDNS_CONFIG_PAT=${LAN_DDNS_CONFIG_PAT:-${NMCONF}/ddns-@LAN@-from-@WAN@.conf}
# DDNS state (must contain "@LAN@-from-@WAN@-@RREC@")
LAN_DDNS_STATE_PAT=${LAN_DDNS_STATE_PAT:-${RUNDIR}/ddns-@LAN@-from-@WAN@-@RREC@.state}

# load WAN config (with defaults)
WAN_DHCLIENT_OPTIONS='' WAN_LAN_INTFS=''
WAN_STATIC_IP6='' WAN_STATIC_DNS6='' WAN_STATIC_DNS6_SEARCH=''
nmg_required_config "${WAN_CONFIG_PAT/@WAN@/${interface}}"

# internal state
RADVD_TRIGGER='' CUR_TIME='' EXIT_CODE=''
NM_MODIFIED='' CONN_ID='' NM_CONFIG=''

ipv6_life_calc() { # return 0 if <retval> set, 1 if offset unavailable
  # <retval> <life> <start>
  (( $2 >= 4294967295 )) && { printf -v "$1" "%s" "forever"; return 0; }
  [[ ${CUR_TIME} ]] || {
    nmg::saferun CUR_TIME "" "${NMDATE}" "+%s" || CUR_TIME=0; }
  [[ ${CUR_TIME} == 0 ]] && return 1
  # sanity check time
  (( CUR_TIME < $3 )) && return 1
  local offset life=0
  (( offset = CUR_TIME - $3, ( $2 > offset ) && ( life = $2 - offset ) )) || :
  printf -v "$1" "%s" "${life}"
  return 0
}

ipv6_handle_ddns_cb() { # returns 0
  # <file> <iaid> <interface>
  local state addr6 pref start plife

  # load address
  nmg::read state "" "$1" || return 0
  nmg::prop_get_value addr6 "${state}" "inet6" || return 0

  # if pref-life 0, don't place in DNS (shouldn't be used for
  # new connections) - use state values to avoid races
  if nmg::prop_get_value pref "${state}" "pref-life" &&
      nmg::prop_get_value start "${state}" "life-start" &&
      ipv6_life_calc plife "${pref}" "${start}"; then
    [[ ${plife} == 0 ]] && return 0
  fi

  # ensure address is applied and ready
  nmg::wait_dad6 "$3" "${addr6}" && ddns_addrs+=("${addr6%%/*}")

  return 0
}

ipv6_handle_ddns() { # returns 0
  # <pat_with_@ID@> <interface> <ddns-config> <ddns-state-pat>
  local ddns_addrs=() action=down IFS; unset IFS

  # DDNS available?
  [[ ${NMDDNS} ]] || return 0

  # any ddns config?
  [[ -e $3 ]] || return 0

  # gather addresses in ddns_addrs
  nmg::foreach_filematch "$1" "@ID@" ipv6_handle_ddns_cb "$2"

  IFS=,; local addrs="${ddns_addrs[*]-}"; unset IFS

  # address present determines "up" or "down", not interface state
  [[ ${addrs} ]] && action=up

  nmddns_spawn_update_all "${action}" "$3" "" "${addrs}" "$4" || :
}

ipv6_prefix_lan_ddns() { # returns 0
  # <interface>
  local sfile=${LAN_STATE_PAT/@WAN@/${interface}}
  ipv6_handle_ddns \
    "${sfile/@LAN@/$1}" "$1" \
    "${LAN_DDNS_CONFIG_PAT/@LAN@-from-@WAN@/${1}-from-${interface}}" \
    "${LAN_DDNS_STATE_PAT/@LAN@-from-@WAN@/${1}-from-${interface}}"
}

ipv6_lan_del_addr() { # returns 0
  # <interface> <addr/plen>

  # flag radvd trigger (not WAN)
  nmg_del_ip6_addr "$1" "$2" && RADVD_TRIGGER=1

  return 0
}

ipv6_add_addr() { # returns 0
  # <interface> <addr/plen>
  local vlife=0 plife=0
  if [[ ${new_max_life-} && ${new_preferred_life-} && ${new_life_starts-} ]] &&
       ipv6_life_calc vlife "${new_max_life}" "${new_life_starts}" &&
       ipv6_life_calc plife "${new_preferred_life}" "${new_life_starts}"; then
    # don't add if address expired
    [[ ${vlife} == 0 ]] && return 0
    nmg_add_ip6_addr "$1" "$2" valid_lft "${vlife}" \
                     preferred_lft "${plife}" || return 0
  else
    nmg_add_ip6_addr "$1" "$2" || return 0
  fi

  # flag radvd trigger (for later)
  RADVD_TRIGGER=1

  # NM sets forwarding to 0 if managed and not method=shared, correct that
  if [[ ${Forwarding} == 1 && -w ${FORWARDING_PAT//@NODE@/$1} ]]; then
    nmg_write "${FORWARDING_PAT//@NODE@/$1}" 1 || :
  fi
  return 0
}

ipv6_lan_node_remove() { # returns 0
  # <state-file> <lan>[-from-<iaid>]
  local sfile=$1 lan=$2 state addr6

  [[ ${sfile} && ${lan} ]] || return 0

  nmg::read state "ignore" "${sfile}"

  # remove state file
  [[ -e ${sfile} ]] && nmg_remove "${sfile}"

  nmg::prop_get_value addr6 "${state}" "inet6" || return 0

  # delete matching addr (if any, remove "-from-<iaid>" if present)
  ipv6_lan_del_addr "${lan%-from-*}" "${addr6}"

  return 0
}

ipv6_lan_reset_config() { # returns 0
  unset LAN_NODE LAN_PREFIX_LEN LAN_SITE
}

ipv6_lan_read_config() { # returns 0
  # <interface>

  # clear config
  ipv6_lan_reset_config

  # load LAN config (with defaults)
  LAN_PREFIX_LEN=64 LAN_SITE=auto LAN_NODE=auto

  nmg_read_config \
    "${LAN_CONFIG_PAT/@LAN@-from-@WAN@/${1}-from-${interface}}" || :

  # check values (node/site can't be empty)
  LAN_NODE=${LAN_NODE:-auto}
  LAN_SITE=${LAN_SITE:-auto}
  LAN_PREFIX_LEN=${LAN_PREFIX_LEN:-64}
}

# checks if <dec>/<plen> overlaps with <prefix>
ipv6_prefix_overlap() { # returns true if overlap
  # <site> <plen> <prefix>
  local site=$1 plen=$2 xsite=${3%/*} xlen=${3#*/} mlen
  (( mlen = ((plen < xlen) ? plen : xlen),
     site = site >> (plen - mlen),
     xsite = xsite >> (xlen - mlen),
     site == xsite )) || return
}

# sets <retvar> to first site/<plen> in <pspace> not overlapping any <prefix>
ipv6_find_freesite() { # returns true if found
  # <retvar> <pspace> <plen> [ <prefix>... ]
  local _retvar=$1 _pspace=$2 _plen=$3 _p='' _site _maxsite

  shift 3
  # pspace <= plen checked during load
  (( _maxsite = ( 1 << (_plen - _pspace) ) - 1 )) || :

  # find site/plen not in <prefix> list
  for (( _site=0; _site <= _maxsite; _site++ )); do
    for _p in "$@"; do
      [[ ${_p} ]] && ipv6_prefix_overlap "${_site}" "${_plen}" "${_p}" && break
      _p=''
    done
    # found non-overlapping site?
    [[ -z ${_p} ]] && { printf -v "${_retvar}" "%d" "${_site}"; return; }
  done
  return 1
}

# uses Assigned, Reserved
# sets <retvar> to prefix not Reserved (if possible), or not Assigned
ipv6_find_autosite() { # return 0 if found, else !0
  # <retvar> <pspace> <plen>

  # any prefix not Assigned+Reserved?
  ipv6_find_freesite "$@" "${Assigned[@]-}" "${Reserved[@]-}" && return

  # fallback: any prefix not Assigned?
  ipv6_find_freesite "$@" "${Assigned[@]-}" && return
}

ipv6_foreach_lan() {
  # <callback> [ <args> ]

  # call callback [(<intf>)] for each LAN in WAN_LAN_INTFS.
  local func=$1 lan IFS; unset IFS
  shift
  for lan in ${WAN_LAN_INTFS-}; do "${func}" "${lan}" "$@"; done

  return 0
}

# uses sets Lans, Reserved
ipv6_lan_node_load() { # returns 0
  # <lan> <pspace>
  local lan=$1 pspace=$2 plen site maxsite

  ipv6_lan_read_config "${lan}"

  [[ -z ${LAN_NODE} ]] && {
    Lans+=("${lan}")
    return
  }

  nmg::2dec plen "${LAN_PREFIX_LEN}" || plen=0

  (( plen <= 0 || plen > 128 )) && {
    nmg_err "${lan} config error, invalid LAN_PREFIX_LEN '${LAN_PREFIX_LEN}'"
    Lans+=("${lan}")
    return
  }

  (( plen > 64 )) && {
    # host address, use site=0
    Lans+=("${lan} 128 ${LAN_NODE} 0")
    return
  }

  (( plen < pspace )) && {
    nmg_info "${lan} not configured, LAN_PREFIX_LEN ${plen} < available ${pspace}"
    Lans+=("${lan}")
    return
  }

  [[ ${LAN_SITE} == auto ]] && {
    Lans+=("${lan} ${plen} ${LAN_NODE} ${LAN_SITE}")
    return
  }

  nmg::2dec site "0x${LAN_SITE}" || {
    nmg_err "${lan} config error, invalid LAN_SITE '${LAN_SITE}'"
    Lans+=("${lan}")
    return
  }

  # if site too large, mask to allowed size
  (( maxsite = ( 1 << (plen - pspace) ) - 1,
     ( site > maxsite ) && ( site = site & maxsite ) )) || :

  # reserve prefix
  Reserved+=("${site}/${plen}")
  Lans+=("${lan} ${plen} ${LAN_NODE} ${site}")
}

# sets <retvar> if addr found, adds to Assigned
ipv6_lan_node_calc() { # returns 0
  # <retvar> <lan> [ <prefix-len> <node> <site> ]
  local lan=$2 plen=${3-} node=${4-} site=${5-} hsite p
  local pspace=${new_ip6_prefix#*/}

  [[ -z ${site} ]] && return

  if [[ ${site} == auto ]]; then

    ipv6_find_autosite site "${pspace}" "${plen}" || {
      nmg_info "${lan} cannot be configured, no /${plen} prefixes available"
      return
    }
  else

    for p in ${Assigned[*]+"${Assigned[@]}"}; do
      ipv6_prefix_overlap "${site}" "${plen}" "$p" || continue
      # ignore requested site, fallback to autosite
      ipv6_find_autosite site "${pspace}" "${plen}" || {
        nmg_info "${lan} cannot be configured, no /${plen} prefixes available"
        return
      }
      break
    done
  fi

  # convert to hex for prefix calc
  nmg::2hex hsite "${site}"

  # build address prefix and host parts
  local addr_prefix addr_host
  if nmg::create_ip6_prefix addr_prefix "${new_ip6_prefix}" \
                            "${hsite}" "${plen}" &&
      nmg::create_ip6_host addr_host "${lan}" "${node}" &&
      nmg::create_ip6_addr "$1" "${addr_prefix}" "${addr_host}"; then

    # consume prefix space
    Assigned+=("${site}/${plen}")
  fi

  return 0
}

# sets Assigned
ipv6_lan_node_assign() { # returns 0
  # <lan> [ <plen> <node> <site> ]
  local lan=$1 new_addr='' old_addr astate=() state

  ipv6_lan_node_calc new_addr "$@"

  local sfile=${LAN_STATE_PAT/@LAN@-from-@ID@-@WAN@/${lan}-from-${new_iaid}-${interface}}

  if [[ ${new_addr} ]]; then
    if nmg::read state "nolog" "${sfile}" &&
        nmg::prop_get_value old_addr "${state}" "inet6" &&
        [[ ${new_addr} != "${old_addr}" ]]; then
      # remove old (different) address
      nmg_remove "${sfile}"
      ipv6_lan_del_addr "${lan}" "${old_addr}"
    fi

    astate+=("inet6:${new_addr}")
    [[ ${new_max_life-} && ${new_preferred_life-} && ${new_life_starts-} ]] &&
      astate+=("valid-life:${new_max_life}" "pref-life:${new_preferred_life}" \
                                            "life-start:${new_life_starts}")
    # write state even if address isn't added (interface may be added later)
    local IFS=$'\n'; state="${astate[*]}"; unset IFS
    nmg_write "${sfile}" "${state}" || :
    ipv6_add_addr "${lan}" "${new_addr}"
  else
    # not assignment failed, remove any old address
    ipv6_lan_node_remove "${sfile}" "${lan}"
  fi

  return 0
}

ipv6_lan_node_depref() { # returns 0
  # <state-file> <lan>
  local file=$1 lan=$2 state='' addr6='' astate=() new_state

  nmg::read state "" "${file}" || return 0
  nmg::prop_get_value addr6 "${state}" "inet6" || return 0
  if [[ ${cur_max_life:-1} == 0 ]]; then
    # remove address from lan
    nmg_remove "${file}"
    nmg_del_ip6_addr "${lan}" "${addr6}" || :
  else
    astate+=("inet6:${addr6}")
    if [[ ${cur_max_life-} && ${cur_life_starts-} ]]; then
      astate+=("valid-life:${cur_max_life}" \
                    "pref-life:0" "life-start:${cur_life_starts}")
    fi
    local IFS=$'\n'; new_state="${astate[*]}"; unset IFS
    nmg_write "${file}" "${new_state}" || :
    nmg_change_ip6_addr "${lan}" "${addr6}" \
                        valid_lft "${cur_max_life:-0}" preferred_lft 0 || :
  fi
  return 0
}

ipv6_prefix_setup_nodes() {
  local -i pspace=${new_ip6_prefix#*/}
  local Forwarding=0 IFS; unset IFS

  # sanity check
  (( pspace <= 0 || pspace > 64 )) && return

  # used by ipv6_add_addr
  nmg::read Forwarding "" "${FORWARDING_PAT//@NODE@/all}" || Forwarding=0

  # check all nodes for config issues
  local args Lans=() Assigned=() Reserved=()

  # load Lans, Reserved
  ipv6_foreach_lan ipv6_lan_node_load "${pspace}"

  # assign lan nodes in order
  for args in ${Lans[*]+"${Lans[@]}"}; do
    # args: lan [ plen node site ]
    # shellcheck disable=SC2086
    ipv6_lan_node_assign ${args}
  done

  return 0
}

ipv6_prefix_flush_id() {
  # <iaid>
  # remove all LAN addresses based on <iaid>
  [[ $1 ]] || return 0
  nmg::foreach_filematch \
    "${LAN_STATE_PAT/@ID@-@WAN@/${1}-${interface}}" "@LAN@" \
    ipv6_lan_node_remove
}

ipv6_prefix_finish() {
  # update all LAN DDNS
  ipv6_foreach_lan ipv6_prefix_lan_ddns

  # trigger radvd if we changed any LAN addresses
  [[ ${RADVD_TRIGGER} ]] && nmg_radvd_trigger
}

ipv6_prefix_start() {

  nmg_debug "prefix-start: new: ${new_ip6_prefix-} old: ${old_ip6_prefix-}"

  if [[ ${new_max_life-} == 0 ]]; then
    # flush dead prefix
    ipv6_prefix_flush_id "${new_iaid-}"
  else
    if [[ ${old_ip6_prefix-} &&
            ${old_ip6_prefix} != "${new_ip6_prefix-}" ]]; then
      # flush old prefix
      ipv6_prefix_flush_id "${old_iaid-}"
    fi

    [[ ${new_ip6_prefix-} && ${new_iaid-} ]] && ipv6_prefix_setup_nodes
  fi

  ipv6_prefix_finish
}

ipv6_prefix_stop() {

  nmg_debug "prefix-stop: ${old_ip6_prefix}"

  ipv6_prefix_flush_id "${old_iaid-}"

  ipv6_prefix_finish
}

ipv6_prefix_depref() {

  nmg_debug "prefix-depref: ${cur_ip6_prefix}"

  # map cur_ to new_
  nmg::foreach_filematch \
    "${LAN_STATE_PAT/@ID@-@WAN@/${cur_iaid}-${interface}}" "@LAN@" \
    ipv6_lan_node_depref

  ipv6_prefix_finish
}

ipv6_prefix_flush() {
  # flush all nodes from this interface
  nmg::foreach_filematch \
    "${LAN_STATE_PAT/@WAN@/${interface}}" "@LAN@-from-@ID@" \
    ipv6_lan_node_remove

  ipv6_prefix_finish
}

ipv6_addr_update_times() { # returns 0
  # <addr6> <valid> <pref> <start>
  local vlife=0 plife=0
  ipv6_life_calc vlife "$2" "$4" || return 0
  ipv6_life_calc plife "$3" "$4" || return 0
  # update times
  nmg_change_ip6_addr "${interface}" "$1" \
                      valid_lft "${vlife}" preferred_lft "${plife}" || :
}

# nmcli device reapply, update lifetimes
ipv6_nm_reapply() { # returns 0 if applied ok, !0 if DAD failure
  local new_addr mod=${NM_MODIFIED}

  NM_MODIFIED=''

  # on flush, don't mess with the device/interface
  [[ ${NM_SKIP_APPLY-} ]] && mod=''

  [[ ${mod} ]] && {
    nmg_cmd "${NMCLI}" device reapply "${interface}" || return 0; }

  # are we recovering from DAD failure?
  [[ ${EXIT_CODE} ]] && return 0

  [[ ${new_ip6_address-} && ${new_ip6_prefixlen-} ]] || return 0

  new_addr="${new_ip6_address}/${new_ip6_prefixlen}"

  if [[ ${mod} ]]; then
    nmg::wait_dad6 "${interface}" "${new_addr}" || {
      # set EXIT_CODE so dhclient performs DECLINE
      nmg_err "DAD timeout for ${new_addr}"; EXIT_CODE=1; return 1; }
  fi
  return 0
}

# compares nm item <name> with ,-list handling duplicates and ordering diffs
ipv6_nm_config_diff() { # return 0 if differ, 1 if same
  # <name> <,-list-with-dups>
  nmg::prop_match_values "${NM_CONFIG}" "$1" "," "$2" && return 1
  return 0
}

# verify iaid (which is a number, possibly hex) for filename use
ipv6_verify_iaid() { # return 0 if valid, !0 otherwise
  # <retvar> <iaid>
  local _id
  [[ ${2-} ]] || return
  nmg::lowercase _id "$2"
  while [[ ${_id} =~ ([^0-9a-f]) ]]; do
    _id=${_id//"${BASH_REMATCH[1]}"}
  done
  [[ ${_id} ]] || {
    nmg_err "dhclient on ${interface} passed invalid IAID '$2'"
    return 1
  }
  printf -v "$1" %s "${_id}" || return
}

ipv6_write_by_iaid() { # returns 0
  # <name-@ID@> <iaid> <data>
  local id
  ipv6_verify_iaid id "$2" || return 0
  nmg_write "${1/@ID@/${id}}" "$3" || :
}

# sets <retvar> to file contents
ipv6_read_state_iaid() { # returns 0 if read, !0 otherwise
  # <retvar> <name-@ID@> <iaid>
  local id
  ipv6_verify_iaid id "$3" || return
  nmg::read "$1" "" "${2/@ID@/$id}" || return
}

ipv6_remove_state_iaid() { # returns 0
  # <name-@ID@> <iaid>
  local id file
  ipv6_verify_iaid id "$2" || return 0
  file=${1/@ID@/${id}}
  [[ -e ${file} ]] && nmg_remove "${file}"
  return 0
}

ipv6_addr_state_times() { # returns 0
  # <state-file> <iaid>
  [[ ${NM_SKIP_APPLY-} ]] && return 0
  local state='' addr6='' valid=0 pref=0 start=0
  nmg::read state "" "$1" || return 0
  nmg::prop_get_value addr6 "${state}" "inet6" || return 0
  nmg::prop_get_value valid "${state}" "valid-life" || return 0
  nmg::prop_get_value pref "${state}" "pref-life" || return 0
  nmg::prop_get_value start "${state}" "life-start" || return 0
  ipv6_addr_update_times "${addr6}" "${valid}" "${pref}" "${start}"
}

# loads addr-state file, adds to addrs(), dns(), and dns_srch()
ipv6_merge_state() { # returns 0
  # <state-file> <iaid (unused)>
  local state val item IFS; unset IFS
  nmg::read state "" "$1" || return 0
  nmg::prop_get_value val "${state}" "inet6" && addrs+=("${val}")
  if nmg::prop_has_value "${NM_CONFIG}" "ipv6.ignore-auto-dns" "no"; then
    if nmg::prop_get_value val "${state}" "dns"; then
      for item in ${val//,/ }; do dns+=("${item}"); done
    fi
    if nmg::prop_get_value val "${state}" "dns-search"; then
      for item in ${val//,/ }; do dns_srch+=("${item}"); done
    fi
  fi
  return 0
}

ipv6_nm_update() { # returns 0
  # merge all iaid files, and apply any changes
  local val xaddrs xdns='' xdns_srch=''
  local addrs=() dns=() dns_srch=() args=()
  local state_pat=${WAN_STATE_PAT/@WAN@/${interface}}

  [[ ${WAN_STATIC_IP6-} ]] && {
    nmg::lowercase val "${WAN_STATIC_IP6}"
    nmg::array addrs "," "${val// }"
  }

  [[ ${WAN_STATIC_DNS6-} ]] && {
    nmg::lowercase val "${WAN_STATIC_DNS6}"
    nmg::array dns "," "${val// }"
  }

  [[ ${WAN_STATIC_DNS6_SEARCH-} ]] && {
    nmg::array dns_srch "," "${WAN_STATIC_DNS6_SEARCH// }"; }

  nmg::foreach_filematch "${state_pat}" "@ID@" ipv6_merge_state

  nmg::array_join xaddrs "," "${addrs[@]-}"
  nmg::array_join xdns "," "${dns[@]-}"
  nmg::array_join xdns_srch "," "${dns_srch[@]-}"

  if ipv6_nm_config_diff "ipv6.addresses" "${xaddrs}" ||
      ipv6_nm_config_diff "ipv6.dns" "${xdns}" ||
      ipv6_nm_config_diff "ipv6.dns-search" "${xdns_srch}"; then

    # we have changes... update NM
    if [[ ${xaddrs} ]]; then
      args+=("ipv6.method" "manual" "ipv6.addresses" "${xaddrs}")
      args+=("ipv6.dns" "${xdns}" "ipv6.dns-search" "${xdns_srch}")
    else
      # if no addresses, make link-local
      args+=("ipv6.method" "link-local" "ipv6.addresses" "")
      args+=("ipv6.dns" "" "ipv6.dns-search" "")
    fi

    nmg_cmd "${NMCLI}" conn modify --temporary "${CONN_ID}" "${args[@]}" &&
      NM_MODIFIED=1
  fi

  ipv6_nm_reapply || {
    # remove new state and re-apply (recursive nm_reapply will not fail
    # as EXIT_CODE is set)
    ipv6_remove_state_iaid "${state_pat}" "${new_iaid-}"
    ipv6_nm_update
    return 0
  }

  # update lifetimes (even if NM not modified, times may change)
  nmg::foreach_filematch "${state_pat}" "@ID@" ipv6_addr_state_times

  return 0
}

ipv6_addr_remove_state() { # <iaid>
  ipv6_remove_state_iaid "${WAN_STATE_PAT/@WAN@/${interface}}" "${old_iaid-}"
}

# addr-state files contain:
#   inet6:<ip6>/<plen> [ valid-life:<life> pref-life:<life> life-start:<ts> ]
#   [ dns:<ip6>[,<ip6>]... ] [ dns-search:<domain>[,<domain>]... ]
ipv6_addr_write_state() {
  local cur_state='' new_state val IFS; unset IFS
  local astate=() dns=() dns_srch=()
  local state_pat=${WAN_STATE_PAT/@WAN@/${interface}}

  [[ ${new_iaid-} && ${new_ip6_address-} && ${new_ip6_prefixlen-} &&
       ${new_max_life:-1} != 0 ]] || {
    ipv6_remove_state_iaid "${state_pat}" "${new_iaid-}"
    return 0
  }

  astate+=("inet6:${new_ip6_address}/${new_ip6_prefixlen}")

  [[ ${new_max_life-} && ${new_preferred_life-} && ${new_life_starts-} ]] &&
    astate+=("valid-life:${new_max_life}" "pref-life:${new_preferred_life}" \
                                          "life-start:${new_life_starts}")

  for val in ${new_dhcp6_name_servers-}; do dns+=("${val}"); done
  nmg::array_join val "," "${dns[@]-}"
  [[ ${val} ]] && astate+=("dns:${val}")

  for val in ${new_dhcp6_domain_search-}; do dns_srch+=("${val}"); done
  nmg::array_join val "," "${dns_srch[@]-}"
  [[ ${val} ]] && astate+=("dns-search:${val}")

  local IFS=$'\n'; new_state="${astate[*]}"; unset IFS

  ipv6_read_state_iaid cur_state "${state_pat}" "${new_iaid}" || :
  [[ ${new_state} == "$cur_state}" ]] ||
    ipv6_write_by_iaid "${state_pat}" "${new_iaid}" "${new_state}"
}

ipv6_addr_ddns() { # returns 0
  ipv6_handle_ddns \
    "${WAN_STATE_PAT/@WAN@/${interface}}" "${interface}" \
    "${WAN_DDNS_CONFIG_PAT/@WAN@/${interface}}" \
    "${WAN_DDNS_STATE_PAT/@WAN@/${interface}}"
}

# sets NMCLI='' if nmcli not available
# returns 1 if ipv6.method=auto (w/o override)
# returns 2 if ipv6.method=disabled
ipv6_check_nm() {
  # clear NMCLI until we know it works
  local method nmcli=${NMCLI} IFS; unset IFS; NMCLI=''

  # check if we're a NetworkManager connection
  [[ ${nmcli} ]] || return 0

  # we need nmcli to talk to NM
  command >/dev/null -v "${nmcli}" || {
    nmg_err "${nmcli} not found in path"; return; }

  # check if we can talk to NM
  nmg::saferun CONN_ID "" "${nmcli}" -g "GENERAL.CONNECTION" \
               device show "${interface}" || return 0

  # validate method
  nmg::saferun NM_CONFIG "" "${nmcli}" -t -f ipv6 conn show "${CONN_ID}" ||
    return 0
  # remove spaces from all values
  NM_CONFIG=${NM_CONFIG// }

  nmg::prop_get_value method "${NM_CONFIG}" "ipv6.method" || {
    nmg_err "Unable to locate ipv6.method for ${CONN_ID}"; return 0; }

  # NMCLI works
  NMCLI=${nmcli}

  [[ ${method} == disabled ]] && return 2

  # dhclient will conflict with NM's, unless configured
  # to override this (perhaps RA unmanaged) log an error and quit.
  if [[ ${method} == auto ]]; then
    local v="${NMDH6_DHCLIENT_ARGS[*]}"
    # don't request addresses
    read -r -a NMDH6_DHCLIENT_ARGS <<< "${v/-N}"
    # allow override
    [[ ${NMDH6_IGNORE_METHOD_AUTO} ]] && return
    # allow if we're using a alt port (testing?)
    for v in ${WAN_DHCLIENT_OPTIONS-}; do [[ ${v} == -p ]] && return 0; done
    return 1
  fi
  return 0
}

# return 1 if NMCLI unavail (dhclient-script called) or method auto/disabled
ipv6_check_nm_or_fallback() {

  # check for invalid config (and working nmcli or sets NMCLI=)
  ipv6_check_nm || {
    # method auto/disabled, cleanup state files
    nmg::foreach_filematch \
      "${WAN_STATE_PAT/@WAN@/${interface}}" "@ID@" nmg_remove
    return 1
  }

  if [[ -z ${NMCLI} ]]; then
    # fallback to default dhclient-script (will probably clobber resolv.conf!)
    if [[ ${DHCLIENT_ORIG_SCRIPT} ]]; then
      command >/dev/null -v "${DHCLIENT_ORIG_SCRIPT}" &&
        exec "${DHCLIENT_ORIG_SCRIPT}"

      nm_err "nmcli unavailable and DHCLIENT_ORIG_SCRIPT not found"
    fi
    # just succeed to prevent DECLINE loops
    return 1
  fi

  return 0
}

ipv6_addr_start() {

  nmg_debug "start: new: ${new_ip6_address-} old: ${old_ip6_address-}"

  ipv6_check_nm_or_fallback || return 0

  [[ ${old_iaid-} && ${old_iaid} != "${new_iaid-}" ]] && ipv6_addr_remove_state

  ipv6_addr_write_state
  ipv6_nm_update
  ipv6_addr_ddns
}

ipv6_addr_stop() {

  nmg_debug "stop: ${old_ip6_address}"

  ipv6_check_nm_or_fallback || return 0

  ipv6_addr_remove_state
  ipv6_nm_update
  ipv6_addr_ddns
}

ipv6_start() {
  # is this a prefix delegation or address?
  if [[ ${new_ip6_prefix-} || ${old_ip6_prefix-} ]]; then
    ipv6_prefix_start
  elif [[ ${new_ip6_address-} || ${old_ip6_address-} ]]; then
    ipv6_addr_start
  fi
  return 0
}

ipv6_stop() {

  if [[ ${old_ip6_prefix-} ]]; then
    ipv6_prefix_stop
  elif [[ ${old_ip6_address-} ]]; then
    ipv6_addr_stop
  fi
  return 0
}

ipv6_addr_depref() {

  nmg_debug "depref: ${cur_ip6_address}"

  ipv6_check_nm_or_fallback || return 0

  # map cur_ to new_ (skip dns vals)
  local new_iaid=${cur_iaid} new_ip6_address=${cur_ip6_address}
  local new_ip6_prefixlen=${cur_ip6_prefixlen}
  [[ ${cur_max_life-} && ${cur_life_starts-} ]] && {
    local new_max_life=${cur_max_life} new_life_starts=${cur_life_starts}
    local new_preferred_life=0
  }

  ipv6_addr_write_state
  ipv6_nm_update
  ipv6_addr_ddns
}

ipv6_depref() {
  [[ ${cur_iaid-} ]] || return 0
  if [[ ${cur_ip6_prefix-} ]]; then
    ipv6_prefix_depref
  elif [[ ${cur_ip6_address-} && ${cur_ip6_prefixlen-} ]]; then
    ipv6_addr_depref
  fi
  return 0
}

ipv6_addrs_flush() {
  local NM_SKIP_APPLY=1

  # cleanup state files
  nmg::foreach_filematch \
    "${WAN_STATE_PAT/@WAN@/${interface}}" "@ID@" nmg_remove

  # flush addrs on WAN
  ipv6_check_nm && ipv6_nm_update

  ipv6_addr_ddns
}

ipv6_flush() {
  ipv6_prefix_flush
  ipv6_addrs_flush
}

ipv6_up() {
  local sys rc=0 link_addr=() IFS; unset IFS

  # if NM config invalid, explain why we failed
  ipv6_check_nm || rc=$?
  if (( rc == 1 )); then
    nmg_err "${CONN_ID}: dhclient would conflict with NetworkManagers (set ipv6.method to link-local or manual)"
    exit 1
  elif (( rc == 2 )); then
    nmg_err "${CONN_ID}: ipv6.method = disabled (set ipv6.method to link-local or manual)"
    exit 1
  fi

  # allow autoconfig on WAN to set default route to ipv6 gateway
  # (this handles NM ipv6.method=disabled)
  local rafile=${ACCEPT_RA/@WAN@/${interface}}

  [[ -w ${rafile} ]] && {
    nmg_write "${rafile}" 2 || :
    # update dependent sysctls in case they are off
    for sys in defrtr pinfo rtr_pref; do
      [[ -w ${rafile}_${sys} ]] && { nmg_write "${rafile}_$sys" 1 || :; }
    done
  }

  local pidfile=${DHCLIENT_PID/@WAN@/${interface}}
  # already running?
  if nmg_is_running "${DHCLIENT}" "${pidfile}"; then
    nmg_debug "${DHCLIENT} already running"
  elif nmg::query_ips link_addr "" 6a "${interface}" "" "scope" "link"; then
    # make sure address is active
    if nmg::wait_dad6 "${interface}" "${link_addr[0]}"; then
      # start dhclient to get addresses/prefixes
      # shellcheck disable=SC2086
      nmg_daemon "${DHCLIENT}" -P ${NMDH6_DHCLIENT_ARGS[*]-} -nw \
                 -sf "${DHSCRIPT}" -pf "${pidfile}" \
                 -lf "${LEASES/@WAN@/${interface}}" \
                 ${WAN_DHCLIENT_OPTIONS-} "${interface}"
    else
      nmg_err "Timed out waiting for link address ${link_addr[0]}"
    fi
  else
    nmg_err "Unable to find link-local address on ${interface}"
  fi
  return 0
}

ipv6_down() {

  local pidfile=${DHCLIENT_PID/@WAN@/${interface}}

  # stop the dhclient if it's running
  if nmg_is_running "${DHCLIENT}" "${pidfile}" 1; then
    nmg_cmd "${DHCLIENT}" -x -sf "${DHSCRIPT}" -pf "${pidfile}" \
            "${interface}"
  fi
  nmg_remove "${pidfile}"

  # dhclient -x should call this script with STOP6, but doesn't...
  # work around it.
  ipv6_flush
}

if [[ ${reason-} ]]; then
  nmg_debug "interface: ${interface} reason: ${reason}"

  [[ -e ${RUNDIR} ]] || { nmg_cmd mkdir -p "${RUNDIR}" || exit 0; }

  # since we're a child of dhclient (not NM), don't set cgroup
  # shellcheck disable=SC2034
  NMG_DAEMON_CGROUP=''
fi

case "${reason-}" in
  BOUND6|RENEW6|REBIND6)
    # (old_) new_ values
    ipv6_start
    ;;
  DEPREF6)
    # cur_ values
    ipv6_depref
    ;;
  EXPIRE6|RELEASE6|STOP6)
    # old_ values
    ipv6_stop
    ;;
  *)
    if [[ $1 ]]; then
      # start/stop need dhclient etc
      nmg_need_progs "${DHCLIENT}" "${DHSCRIPT}" || exit
      # DHSCRIPT requires full path
      nmg::realpath DHSCRIPT "${DHSCRIPT}" || exit
      case "$1" in
        start) ipv6_up;;
        stop) ipv6_down;;
      esac
    fi
    ;;
esac

[[ ${EXIT_CODE} ]] && exit ${EXIT_CODE}
: # for loading in tests
