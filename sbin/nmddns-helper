#!/bin/bash
# vim:set ft=sh et sw=2 ts=2:
#
# nmddns-helper v1.1.3 - NMUtils Dynamic DNS helper program
# Author: Scott Shambarger <devel@shambarger.net>
#
# Copyright (C) 2014-2021 Scott Shambarger
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Instructions for use:
#
#   Place somewhere in your dispatcher's PATH.  This helper is called
#   from nmddns_spawn_update to perform asynchronously DDNS updates,
#   and from boot scripts to perform DNS updates after the nameserver
#   has started.
#
#   Usage: nmddns-helper [<interface>] (from bootup, <interface> optional)
#   Usage: nmddns-helper <action> <config-file> <args>... (from ddns-functions)
#
# Requires:
#
#   $NMUTILS/ddns-functions - Dynamic DNS functions
#   $NMUTILS/general-functions - shared functions, used by ddns-functions
#
# Optional, but suggested:
#
#   /etc/NetworkManager/dispatcher.d/09-ddns - NM trigger script
#   /etc/systemd/system/ddns-onboot@<interface>.service (systemd)
#   rc.local (add "nmddns-helper [<interface>]")
#

# for logging
NMG_TAG="${NMG_TAG-nmddns}"

# set NMUTILS/NMCONF early, and allow environment to override
NMUTILS="${NMUTILS:-/etc/nmutils}"
NMCONF="${NMCONF:-$NMUTILS/conf}"

########## Global defaults (customize in $NMCONF/general.conf)

########## Default paths

RUNDIR="${RUNDIR:-/run/nmutils}"

########## SCRIPT START

# shellcheck disable=SC2034
NMDDNS_REQUIRED="1.3.7"

# load ddns-functions
NMDDNS="${NMDDNS:-${NMUTILS}/ddns-functions}"
# shellcheck source=/dev/null
{ [[ -r ${NMDDNS} ]] && . "${NMDDNS}"; } || {
  echo 1>&2 "Unable to load ${NMDDNS}"; exit 2; }

########## Config locations

# NOTE: *_PAT variables must have a single @MATCH@ and @RREC@ keyword
NMDDNS_CONFIG_PAT="${NMDDNS_CONFIG_PAT:-$NMCONF/ddns-@MATCH@.conf}"
NMDDNS_STATE_PAT="${NMDDNS_STATE_PAT:-$RUNDIR/ddns-@MATCH@-@RREC@.state}"

function ddns_update() {
  # <rrec> [<value>]
  local rrec="${1-}" value="${2-}" rc=0

  [[ ${rrec} ]] || return 0

  nmddns_update "${rrec}" "${value}" || rc=$?

  # allow server unreachable...
  (( rc == 25 )) && return 0

  return ${rc}
}

function ddns_interface_rrec() {
  # <interface> <state-pat> <rrec>
  local intf="$1" state_pat="$2" rrec="$3" ipver='' value='' aval=()

  local state="${state_pat//@RREC@/${rrec}}"

  nmg::read value ignore "${state}"
  # first line only...
  value=${value%%$'\n'*}

  if [[ ${value} ]]; then
    # ensure if address, it can be found on the interface
    case ${rrec} in
      A) ipver=4 ;;
      AAAA) ipver=6 ;;
    esac
    [[ ${ipver} ]] && {
      if nmg::query_ips aval "nolog" "${ipver}" "${intf}" "^${value}"; then
        value=${aval[0]%% *}
        nmg_debug "ip${ipver} address ${value} found on ${intf}"
      else
        nmg_debug "ip${ipver} address ${value} not found on ${intf}"
        value=''
      fi
    }
  fi

  ddns_update "${rrec}" "${value}"
}

function ddns_interface() {
  # [ <interface> ]
  local interface=${1-} rc=0 config intf match state_pat name rrec

  local config_pre="${NMDDNS_CONFIG_PAT%@MATCH@*}"
  local config_post="${NMDDNS_CONFIG_PAT##*@MATCH@}"

  for config in "${config_pre}"*"${config_post}"; do

    # config has * if no matches...
    [[ ${config} == "${NMDDNS_CONFIG_PAT/@MATCH@/*}" ]] && break

    # get match part
    match="${config#${config_pre}}"; match="${match%${config_post}}"
    [[ ${match} ]] || continue

    # find interface (remove any -prefix etc)
    intf="${match%%-*}"

    # if we have an interface, make sure we filter for it
    [[ ${interface} && ${interface} != "${intf}" ]] && continue

    # load DDNS config
    nmddns_read_config "${config}" || continue

    # get state file pattern
    state_pat="${NMDDNS_STATE_PAT/@MATCH@/${match}}"

    for name in "${!DDNS_RREC_@}"; do
      [[ ${name} =~ _NAME$ ]] || continue
      name=${name#DDNS_RREC_}
      rrec=${name%_NAME}
      [[ ${rrec} ]] || continue
      ddns_interface_rrec "${intf}" "${state_pat}" "${rrec}" || rc=$?
    done
  done

  return ${rc}
}

function ddns_helper_action() {
  # <action> <config-file> [ <args>... ]
  local action=$1 config=$2; shift 2

  case ${action} in
    update)
      nmddns_required_config "${config}"
      nmddns_update "$@"
      ;;
    up|down)
      nmddns_required_config "${config}"
      nmddns_update_all "${action}" "$@"
      ;;
    *)
      echo 1>&2 "Usage: ${0##*/} [ <interface> ]"
      return 1
      ;;
  esac
}

[[ -e ${RUNDIR} ]] || { nmg_cmd mkdir -p "${RUNDIR}" || exit; }

if [[ ${2-} ]]; then
  ddns_helper_action "$@"
else
  ddns_interface "$@"
fi

# Local Variables:
# mode: sh
# sh-basic-offset: 2
# sh-indentation: 2
# indent-tabs-mode: nil
# End:
