#!/bin/bash
# -*- mode: sh; sh-basic-offset: 2; indent-tabs-mode: nil; -*-
# vim:set ft=sh et sw=2 ts=2:
#
# nmddns-helper v1.2.0 - NMUtils Dynamic DNS helper program
# Author: Scott Shambarger <devel@shambarger.net>
#
# Copyright (C) 2014-2021 Scott Shambarger
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Instructions for use:
#
#   Place somewhere in your dispatcher's PATH.  This helper is called
#   from nmddns_spawn_update to perform asynchronously DDNS updates,
#   and from boot scripts to perform DNS updates after the nameserver
#   has started.
#
#   Usage: nmddns-helper [<interface>] (from bootup, <interface> optional)
#   Usage: nmddns-helper <action> <config-file> <args>... (from ddns-functions)
#
# Requires:
#
#   $NMUTILS/ddns-functions - Dynamic DNS functions
#   $NMUTILS/general-functions - shared functions, used by ddns-functions
#
# Optional, but suggested:
#
#   /etc/NetworkManager/dispatcher.d/09-ddns - NM trigger script
#   /etc/systemd/system/ddns-onboot@<interface>.service (systemd)
#   rc.local (add "nmddns-helper [<interface>]")
#

# for logging
NMG_TAG=${NMG_TAG-nmddns}

# set NMUTILS/NMCONF early, and allow environment to override
NMUTILS=${NMUTILS:-/etc/nmutils}
NMCONF=${NMCONF:-$NMUTILS/conf}

########## SCRIPT START

# shellcheck disable=SC2034
NMDDNS_REQUIRED="1.4.4"

# load ddns-functions
NMDDNS=${NMDDNS:-${NMUTILS}/ddns-functions}
# shellcheck source=/dev/null
{ [[ -r ${NMDDNS} ]] && . "${NMDDNS}"; } || {
  echo 1>&2 "Unable to load ${NMDDNS}"; exit 2; }

[[ ${NMDDNS_VERSION} ]] || {
  nmg_err "${0##*/} requires NMDDNS v${NMDDNS_REQUIRED}+"; exit 2; }

# internal state
EXIT_CODE=''

function ddns_update() {
  # <rrec> [ <value> ]
  local rrec=${1-} value=${2-} rc=0

  [[ ${rrec} ]] || return 0

  nmddns_update "${rrec}" "${value}" || rc=$?

  # ignore server unreachable...
  (( rc != 0 && rc != 25 )) && EXIT_CODE=${rc}
  return 0
}

function ddns_interface_rrec() {
  # <interface> <state-pat> <rrec>
  local intf=$1 state_pat=$2 rrec=$3 ipver='' value='' aval=()

  local state=${state_pat//@RREC@/${rrec}}

  nmg::read value ignore "${state}"
  # first line only...
  value=${value%%$'\n'*}

  if [[ ${value} ]]; then
    # ensure if address, it can be found on the interface
    case ${rrec} in
      A) ipver=4 ;;
      AAAA) ipver=6 ;;
    esac
    [[ ${ipver} ]] && {
      if nmg::query_ips aval "nolog" "${ipver}" "${intf}" "^${value}"; then
        value=${aval[0]%% *}
        nmg_debug "ip${ipver} address ${value} found on ${intf}"
      else
        nmg_debug "ip${ipver} address ${value} not found on ${intf}"
        value=''
      fi
    }
  fi

  ddns_update "${rrec}" "${value}"
}

ddns_interface_cb() {
  # <file> <match> [ <interface> ]
  local config=$1 match=$2 intf=${3-} state_pat name rrec

  [[ ${match} ]] || return 0

  # if we have an interface, make sure we filter for it
  [[ ${intf} && ${intf} != "${match}" ]] && return 0

  # load DDNS config
  nmddns_read_config "${config}" || return 0

  # get state file pattern
  state_pat=${NMDDNS_STATE_PAT/@MATCH@/${match}}

  for name in "${!DDNS_RREC_@}"; do
    [[ ${name} =~ _NAME$ ]] || continue
    name=${name#DDNS_RREC_}
    rrec=${name%_NAME}
    [[ ${rrec} ]] || continue
    ddns_interface_rrec "${intf}" "${state_pat}" "${rrec}"
  done

  return 0
}

ddns_interface() {
  # [ <interface> ]
  nmg::foreach_filematch "${NMDDNS_CONFIG_PAT}" "@MATCH@" \
                         ddns_interface_cb "$@"
}

function ddns_helper_action() {
  # <action> <config-file> [ <args>... ]
  local action=$1 config=$2; shift 2

  case ${action} in
    update)
      nmddns_required_config "${config}"
      ddns_update "$@"
      ;;
    up|down)
      nmddns_required_config "${config}"
      nmddns_update_all "${action}" "$@" || EXIT_CODE=$?
      # ignore server unreachable
      [[ ${EXIT_CODE} == 25 ]] && EXIT_CODE=''
      ;;
    *)
      echo 1>&2 "Usage: ${0##*/} [ <interface> ]"
      EXIT_CODE=1
      ;;
  esac
}

[[ -e ${DDNS_STATE_DIR} ]] || { nmg_cmd mkdir -p "${DDNS_STATE_DIR}" || exit; }

if [[ ${2-} ]]; then
  ddns_helper_action "$@"
else
  ddns_interface "$@"
fi

[[ ${EXIT_CODE} ]] && exit ${EXIT_CODE}
: # for loading in tests
