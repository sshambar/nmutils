#!/bin/bash
# -*- mode: sh; sh-basic-offset: 2; indent-tabs-mode: nil; -*-
# vim:set ft=sh et sw=2 ts=2:
#
# 08-ipv6-prefix v1.99.0 - NetworkManager dispatch for ipv6 prefix delegation
# Author: Scott Shambarger <devel@shambarger.net>
#
# Copyright (C) 2014-2021 Scott Shambarger
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Instructions for use:
#
#   Put this script in /etc/NetworkManager/dispatcher.d (or wherever
#   your distro has these files), and dhclient-ipv6-prefix somewhere in
#   PATH.
#
#   Finally, touch the file NMCONF/ipv6-prefix-<wan>.conf, and optionally
#   put the following setting in it:
#
#     WAN_LAN_INTFS=<lan>
#
#   <wan> is your WAN interface, <lan> is your LAN interface.
#
#   You will want ipv6 forwarding enabled globally for the prefix to be routed,
#   ie. /etc/sysctl.d/ipv6.conf should contain "net.ipv6.conf.all.forwarding=1"
#
#   For a WAN interface, this dispatcher will start dhclient (for ipv6).
#   To ensure NetworkManager isn't already starting a dhclient for ipv6:
#
#     /etc/sysconfig/network-scripts/ifcfg-<wan>.conf: IPV6INIT="no"
#   or
#     ipv6.method=link-local in NetworkManager config
#
#   If you need ipv6.method=auto on WAN, then you MUST supply a different
#   DHCP client port in WAN_DHCLIENT_OPTIONS ("-p <port>" != 546)
#
#   For a LAN interface, this dispatcher will attempt to replace a
#   missing LAN prefix if it comes up after the WAN, or is restarted.
#
# Requires:
#
#   NMUTILS/general-functions - shared functions
#   dhclient-ipv6-prefix - dhclient script
#   dhclient - ISC DHCP client
#
# Supported, but optional:
#
#   NMUTILS/ddns-functions - dynamic DNS functions (DDNS features
#     are unavailable if absent)
#
#   LAN_DDNS_CONFIG_PAT - prefix LAN DDNS, default:
#     ${NMCONF}/ddns-@LAN@-from-@WAN@.conf
#
#   WAN_DDNS_CONFIG_PAT - WAN address DDNS config, default:
#     ${NMCONF}/ddns-@WAN@.conf
#
# WAN config location:
#
#   WAN_CONFIG_PAT - must contain single "@WAN@", default:
#     ${NMCONF}/ipv6-prefix-@WAN@.conf
#
# LAN config location, optional:
#
#   LAN_CONFIG_PAT - must contain single "@LAN@-from-@WAN@", default:
#     ${NMCONF}/ipv6-prefix-@LAN@-from-@WAN@.conf
#
# State files (created by dhclient-ipv6-prefix and this script):
#
#   RUNDIR/ipv6-prefix-<lan>-from-<iaid>-<wan>.state
#   RUNDIR/ipv6-<iaid>-<wan>.state
#   RUNDIR/ddns-<wan>-<rrec>.state
#   RUNDIR/ddns-<lan>-from-<wan>-<rrec>.state
#
# WAN Settings (set in NMCONF/ipv6-prefix-<wan>.conf)
#
#   All settings are optional, but file must exist to trigger prefix query!
#
#   <ip6_prefix>/<ip6_prefix_len> below are the delegated prefix values.
#
#   WAN_DHCLIENT_OPTIONS - any additional dhclient options
#
#   WAN_LAN_INTFS - LAN interfaces (space separated) to assign
#       prefixes to.  See below for optional per-LAN config.  The order
#       determines which LAN interfaces get sub-prefixes if prefix
#       space is limited.
#
#   WAN_REQUIRE_IP4 - if set, requires valid, public ip4 address on
#       interface before starting dhclient (useful if modem assigns
#       private ip4 address when it's offline).  If set to "any", then
#       even private network addresses are accepted.
#
#   WAN_STATIC_IP6 - comma-list of ip6 addresses/plen to add to WAN,
#       allows mixing DHCP and static addresses.
#
#   WAN_STATIC_DNS6 (optional) - comma-list of ip6 dns servers added to WAN.
#
#   WAN_STATIC_DNS6_SEARCH (optional) - comma-list of static dns-search
#       added to WAN.
#
#   NOTE: A default (empty) config will assign a sub-prefix to the WAN.
#
# LAN Settings (set in NMCONF/ipv6-prefix-<lan>-from-<wan>.conf)
#
#   All LAN settings are optional (file does not need to exist).
#
#   LAN_SITE (hex, default: "auto") - (LAN_PREFIX_LEN - <ip6_prefix_len>)
#       bits added <ip6_prefix> to create <lan_prefix>. If "auto" or
#       unset then prefixes are created based on the order the LAN
#       appears WAN_LAN_INTFS.
#
#   LAN_PREFIX_LEN (default: 64) - prefix length to assign to LAN address.
#       Anything over <ip6_prefix_len> can be used for LAN_SITE.
#       128 sets just an address on the interface.
#
#   LAN_NODE (hex, default: "auto") - <lan_prefix>::LAN_NODE is address
#       assigned.  If auto or unset then the link-local address's host
#       part is used.
#
# NOTE: executable paths (see below) may be overriden if needed
#
# shellcheck disable=SC1090

interface="$1"
action="$2"

# for logging
# shellcheck disable=SC2034
NMG_TAG="${NMG_TAG-ipv6-prefix}"

# set NMUTILS/NMCONF early, and allow environment to override
NMUTILS="${NMUTILS:-/etc/nmutils}"
NMCONF="${NMCONF:-${NMUTILS}/conf}"

########## Global defaults (customize in $NMCONF/general.conf)

########## Default paths

RUNDIR="${RUNDIR:-/run/nmutils}"
FORWARDING_PAT="${FORWARDING_PAT:-/proc/sys/net/ipv6/conf/@NODE@/forwarding}"

########## Support programs

DHSCRIPT="${DHSCRIPT:-dhclient-ipv6-prefix}"
NMDATE=${NMDATE:-date}

########## SCRIPT START

# anything for us to do?
[[ ${interface} && ${action} ]] || exit 0

NMG_REQUIRED="1.5.6"
NMDDNS_REQUIRED="1.4.3"

# load ddns- or general-functions
NMDDNS="${NMDDNS-${NMUTILS}/ddns-functions}"
{ [[ -r ${NMDDNS} ]] && . "${NMDDNS}"; } || {
  # no DDNS, use general-functions
  NMDDNS='' NMG="${NMG:-${NMUTILS}/general-functions}"
  { [[ -r ${NMG} ]] && . "${NMG}"; } || {
    echo 1>&2 "Unable to read ${NMG}"; exit 2; }
}

[[ ${NMG_VERSION} ]] || {
  nmg_err "${0##*/} requires NMG ${NMG_REQUIRED}"; exit 2; }
[[ -z ${NMDDNS} || ${NMDDNS_VERSION} ]] || {
  nmg_err "${0##*/} requires NMDDNS ${NMDDNS_REQUIRED}"; exit 2; }

########## Config locations

# main config
WAN_CONFIG_PAT=${WAN_CONFIG_PAT:-${NMCONF}/ipv6-prefix-@WAN@.conf}
# DDNS config (must contain "@LAN@-from-@WAN@")
LAN_DDNS_CONFIG_PAT=${LAN_DDNS_CONFIG_PAT:-${NMCONF}/ddns-@LAN@-from-@WAN@.conf}

# State file locations

# node assignment state (must contain "@LAN@-from-@ID@-@WAN@")
LAN_STATE_PAT=${LAN_STATE_PAT:-${RUNDIR}/ipv6-prefix-@LAN@-from-@ID@-@WAN@.state}
# LAN DDNS state (must contain "@LAN@-from-@WAN@-@RREC@")
LAN_DDNS_STATE_PAT=${LAN_DDNS_STATE_PAT:-${RUNDIR}/ddns-@LAN@-from-@WAN@-@RREC@.state}

# internal state
CUR_TIME=''

function ipv6_read_wan_config() {
  # <wan>
  local config=${WAN_CONFIG_PAT/@WAN@/$1}

  # load WAN config (with defaults)
  WAN_LAN_INTFS='' WAN_REQUIRE_IP4=''
  # shellcheck disable=SC2034
  WAN_DHCLIENT_OPTIONS=''
  nmg_read_config "${config}" || return

  nmg_need_progs "${DHSCRIPT}" || exit
}

ipv6_life_calc() { # return 0 if <retval> set, 1 if offset unavailable
  # <retval> <life> <start>
  (( $2 >= 4294967295 )) && { printf -v "$1" "%s" "forever"; return 0; }
  [[ ${CUR_TIME} ]] || {
    nmg::saferun CUR_TIME "" "${NMDATE}" "+%s" || CUR_TIME=0; }
  [[ ${CUR_TIME} == 0 ]] && return 1
  # sanity check time
  (( CUR_TIME < $3 )) && return 1
  local offset life=0
  (( offset = CUR_TIME - $3, ( $2 > offset ) && ( life = $2 - offset ) )) || :
  printf -v "$1" "%s" "${life}"
  return 0
}

#
# WAN Functions
#

function ipv6_wan_check() {

  [[ ${WAN_REQUIRE_IP4} ]] || return 0

  local priv_ok=''
  [[ ${WAN_REQUIRE_IP4} == any ]] && priv_ok=1

  # if no ip4, fail
  if [[ ${IP4_NUM_ADDRESSES:-0} == 0 ]]; then
    nmg_info "No ip4 addresses available"
    return 1
  fi

  # now see if there's a valid address
  local idx vname
  for (( idx=0; idx < IP4_NUM_ADDRESSES; idx++ )); do
    vname="IP4_ADDRESS_${idx}"
    # check addr (remove netmask and gateway)
    nmg_check_ip4_addr "${!vname%%/*}" "${priv_ok}" && return
  done

  local pub="valid"
  [[ ${priv_ok} ]] || pub="public"
  nmg_info "No ${pub} ip4 addresses available"

  return 1
}

function ipv6_wan_start_dhclient() {
  export interface
  nmg_daemon "${DHSCRIPT}" "start"
}

function ipv6_wan_stop_dhclient() {
  export interface
  nmg_daemon "${DHSCRIPT}" "stop"
}

function ipv6_wan_start() {

  local rc=0
  ipv6_read_wan_config "${interface}" || rc=$?

  # no file ok
  [[ ${rc} == 1 ]] && return 0
  # other error?
  [[ ${rc} != 0 ]] && return ${rc}

  # start dhclient
  if ipv6_wan_check; then
    ipv6_wan_start_dhclient
  else
    ipv6_wan_stop_dhclient
  fi
}

function ipv6_wan_stop() {

  # stop dhclient if we have config
  ipv6_read_wan_config "${interface}" && ipv6_wan_stop_dhclient

  return 0
}

#
# LAN Functions
#

# LAN_DDNS items: <wan>[,<addr6>...]
function ipv6_flag_lan_ddns() { # returns 0
  # <wan> [ <addr6> ]
  local i wan=$1 addr=${2-} IFS; unset IFS

  for (( i = 0; i < ${#LAN_DDNS[*]}; i++ )); do
    [[ ${LAN_DDNS[${i}]%%,*} == "${wan}" ]] || continue
    [[ ${addr} ]] && LAN_DDNS[${i}]+=",${addr}"
    return 0
  done
  LAN_DDNS+=("${wan}${addr:+,${addr}}")
}

function ipv6_lan_add_addr() {
  # <state> <from_wan>
  local state=$1 wan=$2 addr6='' vlife=0 plife=0 start=0

  nmg::prop_get_value addr6 "${state}" "inet6" || return 0
  if nmg::prop_get_value vlife "${state}" "valid-life" &&
      nmg::prop_get_value plife "${state}" "pref-life" &&
      nmg::prop_get_value start "${state}" "life-start" &&
      ipv6_life_calc vlife "${vlife}" "${start}" &&
      ipv6_life_calc plife "${plife}" "${start}"; then
    # don't add if address expired
    [[ ${vlife} == 0 ]] && return 0
    nmg_add_ip6_addr "${interface}" "${addr6}" valid_lft "${vlife}" \
                     preferred_lft "${plife}" || return 0
  else
    nmg_add_ip6_addr "${interface}" "${addr6}" || return 0
    plife=1
  fi

  [[ ${plife} != 0 ]] && ipv6_flag_lan_ddns "${wan}" "${addr6}"

  # flag radvd trigger (for later)
  RADVD_TRIGGER=1

  # NM sets forwarding to 0 if managed and not method=shared, correct that
  if [[ ${Forwarding} == 1 &&
          -w ${FORWARDING_PAT//@NODE@/${interface}} ]]; then
    nmg_write "${FORWARDING_PAT//@NODE@/${interface}}" 1 || :
  fi
  return 0
}

function ipv6_handle_lan_ddns() {
  local item wan addr6 addrs action ddns_vals IFS; unset IFS

  # DDNS available?
  [[ ${NMDDNS} ]] || return 0

  for item in ${LAN_DDNS[*]-}; do

    wan=${item%%,*} addrs='' ddns_vals=()

    if [[ ${wan} != "${item}" ]]; then
      addrs=${item#*,} # remove wan
      for addr6 in ${addrs/,/ }; do
        nmg::wait_dad6 "${interface}" "${addr6}" || continue
        ddns_vals+=("${addr6%%/*}")
      done
      IFS=,; addrs="${ddns_vals[*]-}"; unset IFS
    fi

    # address present determines "up" or "down", not interface state
    [[ ${addrs} ]] && action=up || action=down

    nmddns_spawn_update_all \
      "${action}" \
      "${LAN_DDNS_CONFIG_PAT/@LAN@-from-@WAN@/${interface}-from-${wan}}" "" \
      "${addrs}" "${LAN_DDNS_STATE_PAT/@LAN@-from-@WAN@/${interface}-from-${wan}}"
  done
}

function ipv6_lan_foreach_wan() {
  # <callback> [ <args> ]
  local IFS; unset IFS
  nmg::foreach_filematch "${LAN_STATE_PAT/@LAN@/${interface}}" \
                         "from-@ID@-@WAN@" "$@" || :
}

function ipv6_lan_start_cb() { # returns 0
  # <state-file> from-<iaid>-<wan>
  local file=$1 state='' wan

  # should only remove from-<iaid> since <iaid> cannot include "-"
  wan=${2#from-*-}
  [[ ${wan} ]] || return 0

  ipv6_flag_lan_ddns "${wan}"

  # read address from state
  nmg::read state "ignore" "${file}" || return 0

  # get WAN_LAN_INTFS
  ipv6_read_wan_config "${wan}" || :

  # this LAN still configured for this WAN?
  if [[ ${WAN_LAN_INTFS} =~ (^| )"${interface}"($| ) ]]; then
    ipv6_lan_add_addr "${state}" "${wan}"
  else
    nmg_remove "${file}"
  fi

  return 0
}

function ipv6_lan_start() {

  # used by ipv6_lan_add_addr
  local Forwarding=0 LAN_DDNS=() RADVD_TRIGGER=''

  [[ -r ${FORWARDING_PAT//@NODE@/all} ]] &&
    nmg::read Forwarding "ignore" "${FORWARDING_PAT//@NODE@/all}"

  # set address from each WAN
  ipv6_lan_foreach_wan ipv6_lan_start_cb

  ipv6_handle_lan_ddns

  # trigger radvd if prefix(es) added
  [[ ${RADVD_TRIGGER} ]] && nmg_radvd_trigger
  return 0
}

function ipv6_lan_stop_cb() { # returns 0
  # <state-file> from-<iaid>-<wan>
  local wan

  # should only remove from-<iaid> since <iaid> cannot include "-"
  wan=${2#from-*-}
  [[ ${wan} ]] || return 0

  ipv6_flag_lan_ddns "${wan}"
}

function ipv6_lan_stop() {
  # reset DDNS for each WAN
  local LAN_DDNS=()

  ipv6_lan_foreach_wan ipv6_lan_stop_cb

  ipv6_handle_lan_ddns

  # trigger radvd as prefix(es) removed
  nmg_radvd_trigger
}

nmg_debug "interface: ${interface} action: ${action}"

[[ -e ${RUNDIR} ]] || {
  nmg_cmd mkdir -p "${RUNDIR}" || exit
}

case "${action}" in
  up)
    ipv6_lan_start
    ipv6_wan_start
    ;;
  dhcp4-change)
    ipv6_wan_start
    ;;
  down)
    ipv6_lan_stop
    ipv6_wan_stop
    ;;
esac
